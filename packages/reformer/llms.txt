# ReFormer - LLM Integration Guide

## 1. QUICK REFERENCE

### Imports (CRITICALLY IMPORTANT)

| What                                                                                        | Where                       |
| ------------------------------------------------------------------------------------------- | --------------------------- |
| `createForm`, `useFormControl`, `useFormControlValue`                                       | `@reformer/core`            |
| `ValidationSchemaFn`, `BehaviorSchemaFn`, `FieldPath`, `GroupNodeWithControls`, `FieldNode` | `@reformer/core`            |
| `FormSchema`, `FieldConfig`, `ArrayNode`                                                    | `@reformer/core`            |
| `required`, `min`, `max`, `minLength`, `maxLength`, `email`                                 | `@reformer/core/validators` |
| `pattern`, `url`, `phone`, `number`, `date`                                                 | `@reformer/core/validators` |
| `validate`, `validateAsync`, `validateTree`, `applyWhen`                                    | `@reformer/core/validators` |
| `notEmpty`, `validateItems`                                                                 | `@reformer/core/validators` |
| `computeFrom`, `enableWhen`, `disableWhen`, `watchField`, `copyFrom`                        | `@reformer/core/behaviors`  |
| `resetWhen`, `revalidateWhen`, `syncFields`                                                 | `@reformer/core/behaviors`  |
| `transformValue`, `transformers`                                                            | `@reformer/core/behaviors`  |

### Type Values

- Optional numbers: `number | undefined` (NOT `null`)
- Optional strings: `string` (empty string by default)
- Do NOT add `[key: string]: unknown` to form interfaces

## 2. API SIGNATURES

### Validators

```typescript
// Basic validators
required(path, options?: { message?: string })
min(path, value: number, options?: { message?: string })
max(path, value: number, options?: { message?: string })
minLength(path, length: number, options?: { message?: string })
maxLength(path, length: number, options?: { message?: string })
email(path, options?: { message?: string })

// Additional validators
pattern(path, regex: RegExp, options?: { message?: string })
url(path, options?: { message?: string })
phone(path, options?: { message?: string; format?: PhoneFormat })
number(path, options?: { message?: string })
date(path, options?: { message?: string; minAge?: number; maxAge?: number; noFuture?: boolean; noPast?: boolean })

// Custom validators
validate(path, validator: (value, ctx) => ValidationError | null)
validateAsync(path, validator: async (value, ctx) => ValidationError | null)
validateTree(validator: (ctx) => ValidationError | null, options?: { targetField?: string })

// Conditional validation
applyWhen(fieldPath, condition: (fieldValue) => boolean, validatorsFn: (path) => void)

// Array validators
notEmpty(path, options?: { message?: string })
validateItems(arrayPath, itemValidatorsFn: (itemPath) => void)
```

### Behaviors

```typescript
// Enable/disable fields conditionally
enableWhen(path, condition: (form) => boolean, options?: { resetOnDisable?: boolean })
disableWhen(path, condition: (form) => boolean)

// Computed fields (same nesting level)
computeFrom(sourcePaths[], targetPath, compute: (values) => result, options?: { debounce?: number; condition?: (form) => boolean })

// Watch field changes
watchField(path, callback: (value, ctx: BehaviorContext) => void, options?: { immediate?: boolean; debounce?: number })

// Copy values between fields
copyFrom(sourcePath, targetPath, options?: { when?: (form) => boolean; fields?: string[]; transform?: (value) => value })

// Reset field when condition met
resetWhen(path, condition: (form) => boolean, options?: { toValue?: any })

// Re-validate when another field changes
revalidateWhen(triggerPath, targetPath)

// Sync multiple fields
syncFields(paths[], options?: { bidirectional?: boolean })

// Transform values
transformValue(path, transformer: (value) => value, options?: { on?: 'change' | 'blur' })
transformers.trim, transformers.toUpperCase, transformers.toLowerCase, transformers.toNumber

// BehaviorContext interface:
interface BehaviorContext<TForm> {
  form: GroupNodeWithControls<TForm>;            // Form proxy with typed field access
  setFieldValue: (path: string, value: any) => void;
  getFieldValue: (path: string) => unknown;
}
```

## 3. COMMON PATTERNS

### Conditional Fields with Auto-Reset

```typescript
enableWhen(path.mortgageFields, (form) => form.loanType === 'mortgage', {
  resetOnDisable: true,
});
```

### Computed Field from Nested to Root Level

```typescript
// DO NOT use computeFrom for cross-level computations
// Use watchField instead:
watchField(path.nested.field, (value, ctx) => {
  ctx.setFieldValue('rootField', computedValue);
});
```

### Type-Safe useFormControl

```typescript
const { value } = useFormControl(form.field as FieldNode<ExpectedType>);
```

## 4. ⚠️ COMMON MISTAKES

### Validators

```typescript
// ❌ WRONG
required(path.email, 'Email is required');

// ✅ CORRECT
required(path.email, { message: 'Email is required' });
```

### Types

```typescript
// ❌ WRONG
amount: number | null;
[key: string]: unknown;

// ✅ CORRECT
amount: number | undefined;
// No index signature
```

### computeFrom

```typescript
// ❌ WRONG - different nesting levels
computeFrom([path.nested.a, path.nested.b], path.root, ...)

// ✅ CORRECT - use watchField
watchField(path.nested.a, (_, ctx) => {
  ctx.setFieldValue('root', computed);
});
```

### Imports

```typescript
// ❌ WRONG - types are not in submodules
import { ValidationSchemaFn } from '@reformer/core/validators';

// ✅ CORRECT - types from main module
import type { ValidationSchemaFn } from '@reformer/core';
import { required, email } from '@reformer/core/validators';
```

## 5. TROUBLESHOOTING

| Error                                                  | Cause                          | Solution                          |
| ------------------------------------------------------ | ------------------------------ | --------------------------------- |
| `'string' is not assignable to '{ message?: string }'` | Wrong validator format         | Use `{ message: 'text' }`         |
| `'null' is not assignable to 'undefined'`              | Wrong optional type            | Replace `null` with `undefined`   |
| `FormFields[]` instead of concrete type                | Type inference issue           | Use `as FieldNode<T>`             |
| `Type 'X' is missing properties from type 'Y'`         | Cross-level computeFrom        | Use watchField instead            |
| `Module has no exported member`                        | Wrong import source            | Types from core, functions from submodules |

## 6. COMPLETE IMPORT EXAMPLE

```typescript
// Types - always from @reformer/core
import type {
  ValidationSchemaFn,
  BehaviorSchemaFn,
  FieldPath,
  GroupNodeWithControls,
  FieldNode,
} from '@reformer/core';

// Core functions
import { createForm, useFormControl } from '@reformer/core';

// Validators - from /validators submodule
import { required, min, max, email, validate, applyWhen } from '@reformer/core/validators';

// Behaviors - from /behaviors submodule
import { computeFrom, enableWhen, watchField, copyFrom } from '@reformer/core/behaviors';
```

## 7. FORM TYPE DEFINITION

```typescript
// ✅ CORRECT form type definition
interface MyForm {
  // Required fields
  name: string;
  email: string;

  // Optional fields - use undefined, not null
  phone?: string;
  age?: number;

  // Enum/union types
  status: 'active' | 'inactive';

  // Nested objects
  address: {
    street: string;
    city: string;
  };

  // Arrays - use tuple format for schema
  items: Array<{
    id: string;
    name: string;
  }>;
}
```

## 8. FORMSCHEMA FORMAT (CRITICALLY IMPORTANT)

⚠️ **Every field MUST have `value` and `component` properties!**

### FieldConfig Interface

```typescript
interface FieldConfig<T> {
  value: T | null;              // Initial value (REQUIRED)
  component: ComponentType;     // React component (REQUIRED)
  componentProps?: object;      // Props passed to component
  disabled?: boolean;           // Disable field initially
  validators?: ValidatorFn[];   // Sync validators
  asyncValidators?: AsyncValidatorFn[]; // Async validators
  updateOn?: 'change' | 'blur' | 'submit';
  debounce?: number;
}
```

### Primitive Fields

```typescript
import { Input, Select, Checkbox } from '@/components/ui';

const schema: FormSchema<MyForm> = {
  // String field
  name: {
    value: '',                    // Initial value (REQUIRED)
    component: Input,             // React component (REQUIRED)
    componentProps: {
      label: 'Name',
      placeholder: 'Enter name',
    },
  },

  // Number field (optional)
  age: {
    value: undefined,             // Use undefined, NOT null
    component: Input,
    componentProps: { type: 'number', label: 'Age' },
  },

  // Boolean field
  agree: {
    value: false,
    component: Checkbox,
    componentProps: { label: 'I agree to terms' },
  },

  // Enum/Select field
  status: {
    value: 'active',
    component: Select,
    componentProps: {
      label: 'Status',
      options: [
        { value: 'active', label: 'Active' },
        { value: 'inactive', label: 'Inactive' },
      ],
    },
  },
};
```

### Nested Objects

```typescript
const schema: FormSchema<MyForm> = {
  address: {
    street: { value: '', component: Input, componentProps: { label: 'Street' } },
    city: { value: '', component: Input, componentProps: { label: 'City' } },
    zip: { value: '', component: Input, componentProps: { label: 'ZIP' } },
  },
};
```

### Arrays (Tuple Format)

```typescript
const itemSchema = {
  id: { value: '', component: Input, componentProps: { label: 'ID' } },
  name: { value: '', component: Input, componentProps: { label: 'Name' } },
};

const schema: FormSchema<MyForm> = {
  items: [itemSchema],  // Array with ONE template item
};
```

### ❌ WRONG - This will NOT compile

```typescript
// Missing value and component - TypeScript will error!
const schema = {
  name: '',           // ❌ Wrong
  email: '',          // ❌ Wrong
};
```

### createForm API

```typescript
// Full config with behavior and validation
const form = createForm<MyForm>({
  form: formSchema,              // Required: form schema with FieldConfig
  behavior: behaviorSchema,      // Optional: behavior rules
  validation: validationSchema,  // Optional: validation rules
});

// Access form controls
form.name.setValue('John');
form.address.city.value.value; // Get current value
form.items.push({ id: '1', name: 'Item' }); // Array operations
```

## 9. ARRAY SCHEMA FORMAT

```typescript
// ✅ CORRECT - use tuple format for arrays
const schema = {
  items: [itemSchema] as [typeof itemSchema],
  properties: [propertySchema] as [typeof propertySchema],
};

// ❌ WRONG - object format is NOT supported
const schema = {
  items: { schema: itemSchema, initialItems: [] }, // This will NOT work
};
```

## 10. ASYNC WATCHFIELD (CRITICALLY IMPORTANT)

```typescript
// ✅ CORRECT - async watchField with ALL safeguards
watchField(
  path.parentField,
  async (value, ctx) => {
    if (!value) return;  // Guard clause

    try {
      const { data } = await fetchData(value);
      ctx.form.dependentField.updateComponentProps({ options: data });
    } catch (error) {
      console.error('Failed:', error);
      ctx.form.dependentField.updateComponentProps({ options: [] });
    }
  },
  { immediate: false, debounce: 300 }  // REQUIRED options
);

// ❌ WRONG - missing safeguards
watchField(path.field, async (value, ctx) => {
  const { data } = await fetchData(value);  // Will fail silently!
});
```

### Required Options for async watchField:
- `immediate: false` - prevents execution during initialization
- `debounce: 300` - prevents excessive API calls (300-500ms recommended)
- Guard clause - skip if value is empty
- try-catch - handle errors explicitly

## 11. ARRAY CLEANUP PATTERN

```typescript
// ✅ CORRECT - cleanup array when checkbox unchecked
watchField(
  path.hasItems,
  (hasItems, ctx) => {
    if (!hasItems && ctx.form.items) {
      ctx.form.items.clear();
    }
  },
  { immediate: false }
);

// ❌ WRONG - no immediate: false, no null check
watchField(path.hasItems, (hasItems, ctx) => {
  if (!hasItems) ctx.form.items.clear();  // May crash on init!
});
```

## 12. MULTI-STEP FORM VALIDATION

```typescript
// Step-specific validation schemas
const step1Validation: ValidationSchemaFn<Form> = (path) => {
  required(path.loanType);
  required(path.loanAmount);
};

const step2Validation: ValidationSchemaFn<Form> = (path) => {
  required(path.personalData.firstName);
  required(path.personalData.lastName);
};

// STEP_VALIDATIONS map for useStepForm hook
export const STEP_VALIDATIONS = {
  1: step1Validation,
  2: step2Validation,
};

// Full validation (combines all steps)
export const fullValidation: ValidationSchemaFn<Form> = (path) => {
  step1Validation(path);
  step2Validation(path);
};
```

## 13. ⚠️ EXTENDED COMMON MISTAKES

### Behavior Composition (Cycle Error)

```typescript
// ❌ WRONG - apply() in behavior causes "Cycle detected"
const mainBehavior: BehaviorSchemaFn<Form> = (path) => {
  apply(addressBehavior, path.address);  // WILL FAIL!
};

// ✅ CORRECT - inline or use setup function
const setupAddressBehavior = (path: FieldPath<Address>) => {
  watchField(path.region, async (region, ctx) => {
    // ...
  }, { immediate: false });
};

const mainBehavior: BehaviorSchemaFn<Form> = (path) => {
  setupAddressBehavior(path.address);  // Works!
};
```

### Infinite Loop in watchField

```typescript
// ❌ WRONG - causes infinite loop
watchField(path.field, (value, ctx) => {
  ctx.form.field.setValue(value.toUpperCase());  // Loop!
});

// ✅ CORRECT - write to different field OR add guard
watchField(path.input, (value, ctx) => {
  const upper = value?.toUpperCase() || '';
  if (ctx.form.display.value.value !== upper) {
    ctx.form.display.setValue(upper);
  }
}, { immediate: false });
```

### validateTree Typing

```typescript
// ❌ WRONG - implicit any
validateTree((ctx) => { ... });

// ✅ CORRECT - explicit typing
validateTree((ctx: { form: MyForm }) => {
  if (ctx.form.field1 > ctx.form.field2) {
    return { code: 'error', message: 'Invalid' };
  }
  return null;
});
```

## 14. PROJECT STRUCTURE (COLOCATION)

```
src/
├── components/ui/                    # Reusable UI components
│   ├── FormField.tsx
│   └── FormArrayManager.tsx
│
├── forms/
│   └── [form-name]/                  # Form module
│       ├── type.ts                   # Main form type
│       ├── schema.ts                 # Main schema
│       ├── validators.ts             # Validators
│       ├── behaviors.ts              # Behaviors
│       ├── [FormName]Form.tsx        # Main component
│       │
│       ├── steps/                    # Multi-step wizard
│       │   ├── loan-info/
│       │   │   ├── type.ts
│       │   │   ├── schema.ts
│       │   │   ├── validators.ts
│       │   │   ├── behaviors.ts
│       │   │   └── LoanInfoForm.tsx
│       │   └── ...
│       │
│       └── sub-forms/                # Reusable sub-forms
│           ├── address/
│           └── personal-data/
```

### Key Files

```typescript
// forms/credit-application/type.ts
export type { LoanInfoStep } from './steps/loan-info/type';
export interface CreditApplicationForm {
  loanType: LoanType;
  loanAmount: number;
  // ...
}

// forms/credit-application/schema.ts
import { loanInfoSchema } from './steps/loan-info/schema';
export const creditApplicationSchema = {
  ...loanInfoSchema,
  monthlyPayment: { value: 0, disabled: true },
};

// forms/credit-application/validators.ts
import { loanValidation } from './steps/loan-info/validators';
export const creditApplicationValidation: ValidationSchemaFn<Form> = (path) => {
  loanValidation(path);
  // Cross-step validation...
};
```

### Scaling

| Complexity | Structure |
|------------|-----------|
| Simple | Single file: `ContactForm.tsx` |
| Medium | Separate files: `type.ts`, `schema.ts`, `validators.ts`, `Form.tsx` |
| Complex | Full colocation with `steps/` and `sub-forms/` |

## 15. NON-EXISTENT API (DO NOT USE)

⚠️ **The following APIs do NOT exist in @reformer/core:**

| ❌ Wrong | ✅ Correct | Notes |
|----------|-----------|-------|
| `useForm` | `createForm` | There is no useForm hook |
| `FieldSchema` | `FieldConfig<T>` | Type for individual field config |
| `when()` | `applyWhen()` | Conditional validation function |
| `FormFields` | `FieldNode<T>` | Type for field nodes |

### Common Import Errors

```typescript
// ❌ WRONG - These do NOT exist
import { useForm } from '@reformer/core';           // NO!
import { when } from '@reformer/core/validators';   // NO!
import type { FieldSchema } from '@reformer/core';  // NO!
import type { FormFields } from '@reformer/core';   // NO!

// ✅ CORRECT
import { createForm, useFormControl } from '@reformer/core';
import { applyWhen } from '@reformer/core/validators';
import type { FieldConfig, FieldNode } from '@reformer/core';
```

### FormSchema Common Mistakes

```typescript
// ❌ WRONG - Simple values don't work
const schema = {
  name: '',           // Missing { value, component }
  email: '',          // Missing { value, component }
};

// ✅ CORRECT - Every field needs value and component
const schema: FormSchema<MyForm> = {
  name: {
    value: '',
    component: Input,
    componentProps: { label: 'Name' },
  },
  email: {
    value: '',
    component: Input,
    componentProps: { label: 'Email', type: 'email' },
  },
};
```
